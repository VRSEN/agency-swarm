---
title: "Hybrid Patterns: Combining SendMessage and Handoffs"
description: "Learn how to effectively combine Agency Swarm's SendMessage tools with OpenAI SDK Handoffs for sophisticated multi-agent coordination."
icon: "arrows-split-up-and-left"
---
<Warning>
This page only applies to newer versions of the library (v1.0 and higher)
</Warning>

Agency Swarm supports two powerful paradigms for inter-agent communication that can work together seamlessly: **SendMessage tools** (orchestrator pattern) and **OpenAI SDK Handoffs** (sequential pattern). This guide explains how these patterns interact and provides practical examples for building sophisticated multi-agent systems.

## Understanding the Two Paradigms

### SendMessage Tools (Orchestrator Pattern)
- **Control Flow**: Control **returns** to the calling agent
- **Use Case**: Delegation with oversight and coordination
- **Implementation**: Via `SendMessage` tool variants
- **Example**: `Orchestrator -> Worker -> Response to Orchestrator`

### Handoffs (Sequential Pattern)
- **Control Flow**: Control **transfers** to the handoff target
- **Use Case**: Complete task delegation and specialization
- **Implementation**: Via `SendMessageHandoff` tool class + OpenAI SDK
- **Example**: `Worker -> Specialist` (control stays with Specialist)

## The Hybrid Resolution

When both patterns are used together, Agency Swarm implements a **sophisticated hybrid approach** that allows both to coexist without conflicts:

### How It Works

1. **Orchestrator Pattern Dominates at Tool Level**
   - `SendMessage.on_invoke_tool()` always returns results to the calling agent
   - The orchestrator pattern's contract is preserved

2. **Sequential Handoffs Work Within Recipient Execution**
   - During the recipient's `get_response()` execution, handoffs can occur
   - The OpenAI SDK handles handoffs internally
   - Specialist insights are incorporated into the recipient's response

3. **Hybrid Behavior Emerges**
   - The recipient coordinates with specialists via handoffs
   - The recipient formulates a comprehensive response including handoff results
   - The orchestrator receives full visibility into the handoff process

## Setting Up Handoffs

In this library, handoffs are configured via the `SendMessageHandoff` tool.

```python
from agency_swarm import Agency, Agent
from agency_swarm.tools import SendMessageHandoff

# Create specialized agents
orchestrator = Agent(
    name="ProjectManager",
    instructions="Coordinate project tasks and oversee completion",
    # ... other config
)

worker = Agent(
    name="Developer",
    instructions="Handle development tasks, consult specialists when needed",
    send_message_tool_class=SendMessageHandoff,
    # ... other config
)

specialist = Agent(
    name="SecurityExpert",
    instructions="Provide security expertise and recommendations",
    # Agent description will be added to the handoff tool instructions
    description="Provides security expertise and recommendations",
    # ... other config
)

# Create agency with communication flows
agency = Agency(
    orchestrator,
    communication_flows=[
        (orchestrator, worker),      # Creates send_message_to_Developer tool
        (orchestrator, specialist),  # Creates send_message_to_SecurityExpert tool
        (worker, specialist),        # Creates a handoff from worker to specialist (since worker has a special send message class)
    ]
)
```

### Execution Flow

1. **ProjectManager** uses `send_message_to_Developer`: *"Implement user authentication with security best practices"*

2. **Developer** receives the task and decides to consult the security expert

3. **Developer** hands off to **SecurityExpert** (internal to Developer's execution)

4. **SecurityExpert** provides security recommendations

5. **Developer** incorporates the expert advice and responds to **ProjectManager**

6. **ProjectManager** receives a comprehensive response with security considerations included

## Advanced Patterns

### Multi-Level Handoffs with Orchestration

```python
# Complex hierarchy: Manager -> Developer (has SendMessageHandoff) -> 
# -> SecurityExpert (has SendMessageHandoff) -> ComplianceOfficer

# Manager can still orchestrate while allowing deep specialization chains
agency = Agency(
    manager,
    communication_flows=[
        (manager, developer),
        (developer, security_expert),
        (security_expert, compliance_officer),
    ]
)
```

## Thread Management

The hybrid pattern includes sophisticated conversation thread management:

- **Top-level calls** (`sender_name=None`): History saved to main user thread
- **Agent-to-agent calls** (`sender_name` provided): History saved with agent-pair metadata for isolated retrieval
- **Handoff coordination**: Context flows through handoff chain without polluting main user thread

## When to Use Hybrid Patterns

### ‚úÖ Ideal Use Cases

- **Hierarchical task delegation with oversight**: Manager needs visibility but workers need specialist consultation
- **Expert consultation workflows**: Agents can consult specialists while maintaining orchestrator control
- **Complex approval processes**: Multiple specialists review work before returning to orchestrator
- **Quality assurance pipelines**: Work flows through specialists but orchestrator tracks progress

### üéØ Design Guidelines

**Use SendMessage when you need**:
- Orchestrator control and visibility
- Coordination between multiple agents
- Responses back to the calling agent
- Workflow orchestration

**Use Sequential Handoffs when you need**:
- Internal agent decision-making
- Specialized task delegation within agent execution
- Expert consultation during task processing
- Seamless specialist integration

**‚ö†Ô∏è Important**: In this library, handoffs must be configured using `SendMessageHandoff` tools only. The `agent.handoffs` parameter is not supported.

**Combine both when you need**:
- Sophisticated multi-agent coordination
- Hierarchical delegation with oversight
- Expert consultation with orchestrator visibility
- Complex workflows requiring both control patterns

## Testing Your Hybrid Implementation

Agency Swarm includes comprehensive tests for hybrid patterns. You can run them to verify your setup:

```bash
# Test handoffs with communication flows
python -m pytest tests/integration/test_agent_handoffs.py -v
```

Key test files:
- [`tests/integration/test_agent_handoffs.py`](https://github.com/VRSEN/agency-swarm/blob/main/tests/integration/test_agent_handoffs.py) - Comprehensive handoff and communication flow testing

## Implementation Details

### SendMessage Tool Behavior
```python
class SendMessage(FunctionTool):
    async def on_invoke_tool(self, context, args_json):
        # Always calls recipient and returns result to caller
        result = await self.recipient_agent.get_response(
            message=message,
            sender_name=self.sender_agent.name,  # Key: preserves orchestrator pattern
            # ... other args
        )
        return str(result.final_output)  # Always returns to caller
```

### Sequential Handoff Integration
- Handoffs configured by adding `SendMessageHandoff` as agent's custom send message tool class
- Handled by OpenAI SDK during agent execution  
- Can occur within `get_response()` call triggered by SendMessage
- Results incorporated into agent's response

## Benefits of the Hybrid Approach

‚úÖ **No Paradigm Conflicts**: Both patterns work together seamlessly
‚úÖ **Orchestrator Visibility**: Calling agents get informed about sequential handoff decisions
‚úÖ **Internal Delegation**: Agents can use sequential handoffs for specialized processing
‚úÖ **Maintained Control**: Orchestrator pattern contract is preserved
‚úÖ **Context Preservation**: Information flows correctly through the system

## Conclusion

Agency Swarm's hybrid paradigm resolution enables sophisticated multi-agent architectures that would be difficult to achieve with either pattern alone. By understanding how SendMessage tools and Sequential Handoffs work together, you can build powerful systems that combine the best of both orchestration and sequential delegation patterns.

The hybrid approach maintains the strengths of both paradigms while eliminating conflicts, giving you the flexibility to design complex multi-agent workflows with confidence.

<Note>
For more details on individual patterns, see the [Overview](./overview) page. For implementation examples, check the [Common Use Cases](./common-use-cases) page.
</Note>
